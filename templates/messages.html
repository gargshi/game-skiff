{% if messages %}
	<div class="messages">
		{% for message in messages %}
			<div class="alert {{ message.tags }}">
				<div class="alert-row">
					<div class="dot"></div>
					<div class="alert-message">{{ message }}</div>
				</div>
				<div class="alert-line"></div>
			</div>
		{% endfor %}
	</div>
{% endif %}

<script>
	document.addEventListener("DOMContentLoaded", () => {
		const container = document.querySelector(".messages");
		if (!container) return;

		const alerts = Array.from(container.querySelectorAll(".alert"));

		// ====== CONFIGURATION ======
		const stepY = 10;
		const stepZ = -20;
		const baseTimeout = 10000; // ms per toast
		const fadeDuration = 400; // ms
		let pauseStates = new WeakMap(); // store per-alert pause info

		// ====== BASE CONTAINER STYLES ======
		Object.assign(container.style, {
			position: "fixed",
			top: "2rem",
			left: "50%",
			display: "grid",
			placeItems: "center",
			perspective: "800px",
			opacity: 0,
			zIndex: 9999,
			transition: "opacity 1s linear",
		});
		setTimeout(() => (container.style.opacity = 1), 100);

		// ====== STYLE EACH ALERT ======
		alerts.forEach(alert => {
			Object.assign(alert.style, {
				position: "absolute",
				display: "flex",
				flexDirection: "column",
				alignItems: "flex-start",
				justifyContent: "space-between",
				width: "500px",
				padding: "6px",
				color: "#fff",
				boxShadow: "0 4px 10px rgba(0,0,0,0.3)",
				fontSize: "12px",
				opacity: 0,
				transformStyle: "preserve-3d",
				borderRadius: "6px",
				transition: "transform 0.4s ease, opacity 0.4s ease",
				overflow: "hidden",
				cursor: "pointer",
			});

			const dot = alert.querySelector(".dot");
			const alertMessage = alert.querySelector(".alert-message");
			let type = alert.classList[1];
			alert.classList.add("transparent-bg");
			dot.classList.add(type);
			//alertMessage.classList.add(type);

			const line = alert.querySelector(".alert-line");
			if (line) {
				Object.assign(line.style, {
					position: "absolute",
					bottom: "0",
					left: "0",
					height: "5px",
					width: "100%",
					transition: "width 0.05s linear",
				});
			}
			line.classList.add(type);
		});

		// ====== POSITION STACK ======
		function updatePositions() {
			const current = Array.from(container.querySelectorAll(".alert"));
			current.forEach((a, i) => {
				a.style.transform = `
				translateY(${i * stepY}px)
				translateZ(${i * stepZ}px)
			`;
				a.style.zIndex = 1000 - i;
				a.style.opacity = 1;
			});
		}
		updatePositions();

		// ====== PROGRESS BAR + PAUSE SUPPORT ======
		function startProgress(alert, lifetime = baseTimeout, onFinish) {
			const line = alert.querySelector(".alert-line");
			if (!line) return;

			let start = Date.now();
			let pausedAt = 0;
			let isPaused = false;
			let elapsedWhenPaused = 0;

			function animate() {
				if (isPaused) return; // freeze progress while paused

				const elapsed = Date.now() - start;
				const progress = Math.max(0, 1 - elapsed / lifetime);
				line.style.width = `${progress * 100}%`;

				if (progress > 0) {
					requestAnimationFrame(animate);
				} else {
					line.style.width = "0%";
					if (onFinish) onFinish();
				}
			}

			line.style.width = "100%";
			requestAnimationFrame(animate);

			// hover handlers for pause/resume
			alert.addEventListener("mouseenter", () => {
				if (!isPaused) {
					isPaused = true;
					pausedAt = Date.now();
					elapsedWhenPaused = pausedAt - start;
					pauseStates.set(alert, { paused: true, elapsedWhenPaused });
				}
			});
			alert.addEventListener("mouseleave", () => {
				const state = pauseStates.get(alert);
				if (state && state.paused) {
					isPaused = false;
					start = Date.now() - state.elapsedWhenPaused;
					requestAnimationFrame(animate);
				}
			});
		}

		// ====== FADE + REMOVE ======
		function fadeOut(alert) {
			alert.style.opacity = 0;
			alert.style.transform += " translateY(-20px)";
			setTimeout(() => {
				alert.remove();
				updatePositions();
				const next = container.querySelector(".alert");
				if (next && !next.dataset.running) {
					next.dataset.running = "true";
					startProgress(next, baseTimeout, () => fadeOut(next));
				}
			}, fadeDuration);
		}

		// ====== STARTUP SEQUENCE ======
		const first = alerts[0];
		if (first) {
			first.dataset.running = "true";
			startProgress(first, baseTimeout, () => fadeOut(first));
		}

		alerts.forEach((alert, i) => {
			// Safe fallback if manually closed
			alert.addEventListener("click", () => fadeOut(alert));
		});
	});
</script>